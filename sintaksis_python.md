# Cинтаксис Python / основные команды
1. int -  Целые числа
2. float -Дробные числа
3. bool  - Логический тип данных (True/False)
4. str  - Строка

5. Интерполяция — способ получить сложную строку из нескольких простых с использованием специальных шаблонов.
* a = 3
* b = 11
* s = 2022
* print(a, b, s)
* print(a,'-'b,'-'s)
* print('{} - {} - {}'.format(a,b,s))
* print(f'first - {a} second - {b} third - {s}')

6. str() - функция, которая позволяет перевести из любого типа данных в строку(если это возможно)
* n = 1.345
* print(str(n) * 2)
* вывод: 1.3451.345

7. float() - функция, которая позволяет перевести из любого типа данных в вещественный(если это возможно)
* n = ‘1.345’
* print(float(n) * 2)
* m = 2
* print(float(m))
* вывод
* 2.69
* 2.0

8. Арифметические операции
* + Сложение -  плюс
* - Вычитание - минус
* * Умножение - звездлочка
* / Деление (по умолчанию в вещественных числах)
* % Остаток от деления
* // Целочисленное деление
* ** Возведение в степень

9. Округление числа
* a = 1.43425
* b = 2.2983
* c = round(a * b, 5)   # получается 3,29633

10. Сокращенные операции присваивания
* iter = 2
* iter += 3 # iter = iter + 3
* iter -= 4 # iter = iter - 4
* iter *= 5 # iter = iter * 5
* iter /= 5 # iter = iter / 5
* iter //= 5 # iter = iter // 5
* iter %= 5 # iter = iter % 5
 * iter **= 5 # iter = iter ** 5

11. Логические операции
* > Больше
>= Больше или равно
* < Меньше
* <= Меньше или равно
* == Равно (проверяет, равны ли числа)
* != Не равно (проверяет, не равны ли значения)
* not Не (отрицание)
* and И (конъюнкция)
* or Или (дизъюнкция)

12. Определить количество символов в строке:
* print(len(text))
13. Проверить наличие символа в строке (in):
* print('ещё' in text)
14. Функция, которая делает все буквы строки маленькими:
* print(text.lower())
15. Функция, которая делает все буквы строки большими:
* print(text.upper()) 
16. Заменить слово на другое :
* print(text.replace('ещё','ЕЩЁ')) 

17. Срезы-обращение к элементам по индексам
* text = 'съешь ещё этих мягких французских булок'
* print(text[0]) # c
* print(text[1]) # ъ
* print(text[len(text)-1]) # к
* print(text[-5]) # б
* print(text[:]) # съешь ещё этих мягких французских булок
* print(text[:2]) # съ
* print(text[len(text)-2:]) # ок
* print(text[2:9]) # ешь ещё
* print(text[6:-18]) # ещё этих мягких
* print(text[0:len(text):6]) # сеикакл
* print(text[::6]) # сеикакл
* text = text[2:9] + text[-5] + text[:2] # ...

18. Список - это упорядоченный конечный набор элементов. Давайте разбираться, по сути список - это тот же самый массив, в котором можно хранить элементы любыхтипов данных.
* list_1 = [] # Создание пустого списка
* list_2 = list() # Создание пустого списка
* list_1 = [7, 9, 11, 13, 15, 17]
19. В списках существует нумерация, которая начинается с 0, чтобы вывести первыйэлемент списка воспользуемся следующей конструкцией
* list_1 = [7, 9, 11, 13, 15, 17]
* print(list_1[0]) # 7
20. Чтобы узнать количество элементов в списке необходимо использовать функцию len(имя_списка):
* list_1 = list() # создание пустого списка
* for i in range(5): # цикл выполнится 5 раз
* n = int(input()) # пользователь вводит целое число
* list_1.append(n) # сохранение элемента в конец списка
21. Взаимодействие цикла for со списком:
* list_1 = [12, 7, -1, 21, 0]
* for i in list_1:
* print(i) # вывод каждого элемента списка
22. Метод _pop_ удаляет последний элемент из списка:
* list_1 = [12, 7, -1, 21, 0]
* print(list_1.pop()) # 0
* print(list_1) # [12, 7, -1, 21]
* print(list_1.pop()) # 21
* print(list_1) # [12, 7, -1]
* print(list_1.pop()) # -1
* print(list_1) # [12, 7]
23. удаление конкретного элемента из списка
* list_1 = [12, 7, -1, 21, 0]
* print(list_1.pop(0)) # 12
* print(list_1) # [7, -1, 21, 0]
24. Добавление элемента на нужную позицию. Функция _insert_ — указание индекса (позиции) и значения.
* list_1 = [12, 7, -1, 21, 0]
* print(list1.insert(2, 11))
* print(list1) # [12, 7, 11, -1, 21, 0]
25. СРЕЗ СПИСКА,● Отрицательное число в индексе — счёт с конца списка
* list_1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
* print(list_1[0]) # 1 выводит 1й эелемент из списка
* print(list_1[1]) # 2 выводит 2й элемент из списка
* print(list_1[len(list_1)-1]) # 10 выводит кол-во элементов в списке
* print(list_1[-5]) # 6 выводит 5й элемент с конца списка
* print(list_1[:]) # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] выводит весь список
* print(list_1[:2]) # [1, 2] выводит до 2го индекса список
* print(list_1[len(list_1)-2:]) #[9, 10] выводит 2 послед.элемента
* print(list_1[2:9]) # [3, 4, 5, 6, 7, 8, 9] выводит с 3го по 9й элемент
* print(list_1[6:-18]) # [] пустой список.
* print(list_1[0:len(list_1):6]) # [1, 7] 7 - кол-во элементов с начала списка с шагом 6 элементов
* print(list_1[::6]) # [1, 7]кол-во элементов с начала списка с шагом 6 элементов
26. Кортеж — это неизменяемый список.
Тогда для чего нужны кортежи, если их нельзя изменить? В случае защиты каких-либо данных от изменений (намеренных или случайных). Кортеж занимаетменьше места в памяти и работают быстрее, по сравнению со списками
* t = () # создание пустого кортежа
* print(type(t)) # class <'tuple'>
* t = (1,) в конце обяз-но ставим ,
* print(type(t))
* t = (1)
* print(type(t))
* t = (28, 9, 1990) - список
* print(type(t)) -преобразуем в кортедж
* colors = ['red', 'green', 'blue']
* print(colors) # ['red', 'green', 'blue']
* t = tuple(colors) _tuple_ преобразует в кортедж, кортедж выходит в круглых скобках
* print(t) # ('red', 'green', 'blue')
* t = tuple(['red', 'green', 'blue'])
* print(t[0]) # red
* print(t[2]) # blue
* for e in t:
* print(e) # red green blue
* t[0] = 'black' # TypeError: 'tuple' object does not support(нельзя изменять
кортеж)
27. Можно распаковать кортеж в независимые переменные
* t = tuple(['red', 'green', 'blue'])
* red, green, blue = t
* print('r:{} g:{} b:{}'.format(red, green, blue)) #  выводит: r:red g:green b:blue

28. Словари — неупорядоченные коллекции произвольных объектов с доступом по ключу.В списках в качестве ключа используется индекс элемента. В словаре для определения элемента используется значение ключа (строка, число).
* dictionary = {} словарь выводят в фигурных скобках, или команда _d = dict()_
* d['q'] = 'qwerty' - указываем сам ключ
* print(d) -  выводит 'qwerty'
* dictionary ={'up': '↑', 'left': '←', 'down': '↓', 'right': '→'} задаем словарь,СООТВЕТСВУЕТ КОМАНДА:КЛЮЧ
* print(dictionary) # {'up':'↑', 'left':'←', 'down':'↓', 'right':'→'} печатаем весь словарь
* print(dictionary['left']) # ← выводит ключ, кторый принадлежит команде left
# типы ключей могут отличаться
* print(dictionary['up']) # ↑выводит ключ, кторый принадлежит команде UP
# типы ключей могут отличаться
* dictionary['left'] = '⇐'
* print(dictionary['left']) # ⇐
* print(dictionary['type']) # KeyError: 'type' выдает ошибку так как такого ключа нет в словаре
* del dictionary['left'] # удаление элемента из словаря
* for item in dictionary: # for (k,v) in dictionary.items():
* print('{}: {}'.format(item, dictionary[item])) - обращаемся к словарю  с указанием на ключи _format_ - функция обращения, где _item_ - ключ, _dictionary_ - словарь, _[item]_- значение
29. Множества содержат в себе уникальные элементы, не обязательно упорядоченные.
* colors = {'red', 'green', 'blue'} - создаем множество, фигурные скобки и кавычки
* print(colors) # {'red', 'green', 'blue'}
* colors.add('red') - добавляем в множество значение, если это значение уже есть в множестве, то он его не добавит
* print(colors) # {'red', 'green', 'blue'}
* colors.add('gray')
* print(colors) # {'red', 'green', 'blue','gray'}
* colors.remove('red') - удаляем из множества значение
* print(colors) # {'green', 'blue','gray'}
* colors.remove('red') # KeyError: 'red'
* colors.discard('red') # функция _discard_ проверяет есть ли значение в множестве, если его нет, выводит список, если есть, то удаляет его и выводит список. не выдает ошибки в отличие от _remove_
* print(colors) # {'green', 'blue','gray'}
* colors.clear() # { }  - удаляет все элементы из списка
* print(colors) # set() - _set_ -  пустое множество
30. Операции со множествами в Python
* a = {1, 2, 3, 5, 8}
* b = {2, 5, 8, 13, 21}
* c = a.copy() # c = {1, 2, 3, 5, 8} -  в переменную _с_ скопировали множество _а_
* u = a.union(b) # u = {1, 2, 3, 5, 8, 13, - объединение множеств _а_ с _b_
* i = a.intersection(b) # i = {8, 2, 5} - пересечение множеств , выводит общие элементы в обоих множествах
* dl = a.difference(b) # dl = {1, 3} - разница между множеством _а_ и _b_
* dr = b.difference(a) # dr = {13, 21}
* q=a.union(b).difference(a.intersection(b)) # {1, 21, 3, 13}- сначала _a_ объединяем с _b_ заием из полученного множества находим разницу с этим множеством
31. Неизменяемое или замороженное множество(frozenset) — множество, с которым не будут работать методы удаления и добавления.
* a = {1, 2, 3, 5, 8}
* b = frozenset(a)
* print(b) # frozenset({1, 2, 3, 5, 8})

